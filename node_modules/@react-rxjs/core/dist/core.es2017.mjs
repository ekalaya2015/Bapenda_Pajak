var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/bind/connectFactoryObservable.ts
import { noop as noop2, Observable as Observable3 } from "rxjs";

// src/internal/share-latest.ts
import { Observable, Subject, noop, Subscriber } from "rxjs";

// src/internal/empty-value.ts
var EMPTY_VALUE = {};

// src/SUSPENSE.ts
var SUSPENSE = Symbol("SUSPENSE");

// src/internal/share-latest.ts
var shareLatest = (source$, defaultValue, shouldComplete = true, teardown = noop) => {
  let subject;
  let subscription;
  let refCount = 0;
  let currentValue = EMPTY_VALUE;
  let promise;
  const emitIfEmpty = defaultValue === EMPTY_VALUE ? noop : () => {
    currentValue === EMPTY_VALUE && subject && subject.next(currentValue = defaultValue);
  };
  const result = new Observable((subscriber) => {
    if (!shouldComplete)
      subscriber.complete = noop;
    refCount++;
    let innerSub;
    subscriber.add(() => {
      refCount--;
      innerSub.unsubscribe();
      if (refCount === 0) {
        currentValue = EMPTY_VALUE;
        if (subscription) {
          subscription.unsubscribe();
        }
        teardown();
        subject = null;
        subscription = null;
        promise = null;
      }
    });
    if (!subject) {
      subject = new Subject();
      innerSub = subject.subscribe(subscriber);
      subscription = null;
      subscription = new Subscriber({
        next: (value) => {
          subject.next(currentValue = value);
        },
        error: (err) => {
          const _subject = subject;
          subscription = null;
          subject = null;
          _subject.error(err);
        },
        complete: () => {
          subscription = null;
          emitIfEmpty();
          subject.complete();
        }
      });
      source$.subscribe(subscription);
      emitIfEmpty();
    } else {
      innerSub = subject.subscribe(subscriber);
      if (currentValue !== EMPTY_VALUE) {
        subscriber.next(currentValue);
      }
    }
  });
  let error = EMPTY_VALUE;
  let timeoutToken;
  result.gV = (outterSubscription) => {
    if (currentValue !== SUSPENSE && currentValue !== EMPTY_VALUE) {
      return currentValue;
    }
    if (defaultValue !== EMPTY_VALUE)
      return defaultValue;
    if (error !== EMPTY_VALUE) {
      clearTimeout(timeoutToken);
      timeoutToken = setTimeout(() => {
        error = EMPTY_VALUE;
      }, 50);
      throw error;
    }
    if (!subscription) {
      if (!outterSubscription)
        throw new Error("Missing Subscribe");
      let err = EMPTY_VALUE;
      const sub = result.subscribe({
        error(e) {
          err = e;
        }
      });
      if (err !== EMPTY_VALUE)
        throw err;
      outterSubscription.add(sub);
      return result.gV();
    }
    if (promise)
      throw promise;
    throw promise = new Promise((res, rej) => {
      const setError = (e) => {
        error = e;
        timeoutToken = setTimeout(() => {
          error = EMPTY_VALUE;
        }, 50);
        rej(e);
        promise = null;
      };
      const pSubs = subject.subscribe((v) => {
        if (v !== SUSPENSE) {
          pSubs.unsubscribe();
          res(v);
          promise = null;
        }
      }, setError, () => {
        setError(new Error("Empty observable"));
      });
      subscription.add(pSubs);
    });
  };
  return result;
};
var share_latest_default = shareLatest;

// src/internal/useObservable.ts
import { useEffect, useState, useRef } from "react";
var useObservable = (source$, subscription) => {
  const [state, setState] = useState(() => [
    source$.gV(subscription),
    source$
  ]);
  const prevStateRef = useRef(state[0]);
  if (source$ !== state[1]) {
    setState([source$.gV(subscription), source$]);
  }
  useEffect(() => {
    const suspend = () => {
      setState(() => [source$.gV(), source$]);
    };
    const subscription2 = source$.subscribe((value) => {
      if (value === SUSPENSE) {
        suspend();
      } else {
        if (!Object.is(prevStateRef.current, value)) {
          setState([prevStateRef.current = value, source$]);
        }
      }
    }, (error) => {
      setState(() => {
        throw error;
      });
    });
    return () => {
      subscription2.unsubscribe();
    };
  }, [source$]);
  return state[0];
};

// src/Subscribe.tsx
import React, {
  useState as useState2,
  Suspense,
  useEffect as useEffect2,
  useRef as useRef2,
  createContext,
  useContext
} from "react";
import { Subscription as Subscription2 } from "rxjs";
var SubscriptionContext = createContext(null);
var { Provider } = SubscriptionContext;
var useSubscription = () => useContext(SubscriptionContext);
var p = Promise.resolve();
var Throw = () => {
  throw p;
};
var Subscribe = ({ source$, children, fallback }) => {
  const subscriptionRef = useRef2();
  if (!subscriptionRef.current) {
    subscriptionRef.current = new Subscription2();
  }
  const [subscribedSource, setSubscribedSource] = useState2(null);
  if (subscribedSource !== null && subscribedSource !== source$) {
    if (source$ === void 0) {
      setSubscribedSource(source$);
    } else {
      let result;
      try {
        ;
        source$.gV();
        result = source$;
      } catch (e) {
        result = e.then ? source$ : null;
      }
      if (result) {
        setSubscribedSource(result);
      }
    }
  }
  useEffect2(() => {
    const subscription = source$ && source$.subscribe({
      error: (e) => setSubscribedSource(() => {
        throw e;
      })
    });
    setSubscribedSource(source$);
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [source$]);
  useEffect2(() => {
    return () => {
      subscriptionRef.current.unsubscribe();
    };
  }, []);
  const actualChildren = subscribedSource === source$ ? /* @__PURE__ */ React.createElement(Provider, {
    value: subscriptionRef.current
  }, children) : fallback === void 0 ? null : /* @__PURE__ */ React.createElement(Throw, null);
  return fallback === void 0 ? actualChildren : /* @__PURE__ */ React.createElement(Suspense, {
    fallback
  }, actualChildren);
};

// src/bind/connectFactoryObservable.ts
function connectFactoryObservable(getObservable, defaultValue) {
  const cache = new NestedMap();
  const getDefaultValue = typeof defaultValue === "function" ? defaultValue : () => defaultValue;
  const getSharedObservables$ = (input) => {
    for (let i = input.length - 1; input[i] === void 0 && i > -1; i--) {
      input.splice(-1);
    }
    const keys = [input.length, ...input];
    const cachedVal = cache.get(keys);
    if (cachedVal !== void 0) {
      return cachedVal;
    }
    const sharedObservable$ = share_latest_default(new Observable3((observer) => getObservable(...input).subscribe(observer)), getDefaultValue(...input), false, () => {
      cache.delete(keys);
    });
    const publicShared$ = new Observable3((subscriber) => {
      const inCache = cache.get(keys);
      let source$ = sharedObservable$;
      if (!inCache) {
        cache.set(keys, result);
      } else if (inCache !== publicShared$) {
        source$ = inCache;
        publicShared$.gV = source$.gV;
      }
      return source$.subscribe(subscriber);
    });
    publicShared$.gV = sharedObservable$.gV;
    const result = publicShared$;
    cache.set(keys, result);
    return result;
  };
  const useSub = defaultValue === EMPTY_VALUE ? useSubscription : noop2;
  return [
    (...input) => useObservable(getSharedObservables$(input), useSub()),
    (...input) => getSharedObservables$(input)
  ];
}
var NestedMap = class {
  constructor() {
    __publicField(this, "root");
    this.root = new Map();
  }
  get(keys) {
    let current = this.root;
    for (let i = 0; i < keys.length; i++) {
      current = current.get(keys[i]);
      if (!current)
        return void 0;
    }
    return current;
  }
  set(keys, value) {
    let current = this.root;
    let i;
    for (i = 0; i < keys.length - 1; i++) {
      let nextCurrent = current.get(keys[i]);
      if (!nextCurrent) {
        nextCurrent = new Map();
        current.set(keys[i], nextCurrent);
      }
      current = nextCurrent;
    }
    current.set(keys[i], value);
  }
  delete(keys) {
    const maps = [this.root];
    let current = this.root;
    for (let i = 0; i < keys.length - 1; i++) {
      maps.push(current = current.get(keys[i]));
    }
    let mapIdx = maps.length - 1;
    maps[mapIdx].delete(keys[mapIdx]);
    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {
      maps[mapIdx].delete(keys[mapIdx]);
    }
  }
};

// src/bind/connectObservable.ts
import { noop as noop3 } from "rxjs";
function connectObservable(observable, defaultValue) {
  const sharedObservable$ = share_latest_default(observable, defaultValue, false);
  const useSub = defaultValue === EMPTY_VALUE ? useSubscription : noop3;
  const useStaticObservable = () => useObservable(sharedObservable$, useSub());
  return [useStaticObservable, sharedObservable$];
}

// src/bind/index.ts
function bind(observable, defaultValue) {
  return (typeof observable === "function" ? connectFactoryObservable : connectObservable)(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE);
}

// src/shareLatest.ts
var shareLatest2 = () => (source$) => share_latest_default(source$, EMPTY_VALUE);
export {
  SUSPENSE,
  Subscribe,
  bind,
  shareLatest2 as shareLatest
};
//# sourceMappingURL=core.es2017.mjs.map
