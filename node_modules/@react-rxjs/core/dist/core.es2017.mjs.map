{
  "version": 3,
  "sources": ["../src/bind/connectFactoryObservable.ts", "../src/internal/share-latest.ts", "../src/internal/empty-value.ts", "../src/SUSPENSE.ts", "../src/internal/useObservable.ts", "../src/Subscribe.tsx", "../src/bind/connectObservable.ts", "../src/bind/index.ts", "../src/shareLatest.ts"],
  "sourcesContent": ["import { noop, Observable } from \"rxjs\"\nimport shareLatest from \"../internal/share-latest\"\nimport { BehaviorObservable } from \"../internal/BehaviorObservable\"\nimport { useObservable } from \"../internal/useObservable\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { useSubscription } from \"../Subscribe\"\n\n/**\n * Accepts: A factory function that returns an Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @param getObservable Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): [\n  (...args: A) => Exclude<O, typeof SUSPENSE>,\n  (...args: A) => Observable<O>,\n] {\n  const cache = new NestedMap<A, BehaviorObservable<O>>()\n  const getDefaultValue = (\n    typeof defaultValue === \"function\" ? defaultValue : () => defaultValue\n  ) as (...args: A) => O\n\n  const getSharedObservables$ = (input: A): BehaviorObservable<O> => {\n    for (let i = input.length - 1; input[i] === undefined && i > -1; i--) {\n      input.splice(-1)\n    }\n    const keys = [input.length, ...input] as any as A\n    const cachedVal = cache.get(keys)\n\n    if (cachedVal !== undefined) {\n      return cachedVal\n    }\n\n    const sharedObservable$ = shareLatest(\n      new Observable<O>((observer) =>\n        getObservable(...input).subscribe(observer),\n      ),\n      getDefaultValue(...input),\n      false,\n      () => {\n        cache.delete(keys)\n      },\n    )\n\n    const publicShared$ = new Observable<O>((subscriber) => {\n      const inCache = cache.get(keys)\n      let source$: BehaviorObservable<O> = sharedObservable$\n\n      if (!inCache) {\n        cache.set(keys, result)\n      } else if (inCache !== publicShared$) {\n        source$ = inCache\n        publicShared$.gV = source$.gV\n      }\n\n      return source$.subscribe(subscriber)\n    }) as BehaviorObservable<O>\n    publicShared$.gV = sharedObservable$.gV\n\n    const result: BehaviorObservable<O> = publicShared$\n\n    cache.set(keys, result)\n    return result\n  }\n\n  const useSub = defaultValue === EMPTY_VALUE ? useSubscription : noop\n  return [\n    (...input: A) =>\n      useObservable(getSharedObservables$(input), useSub() as any),\n    (...input: A) => getSharedObservables$(input),\n  ]\n}\n\nclass NestedMap<K extends [], V extends Object> {\n  private root: Map<K, any>\n  constructor() {\n    this.root = new Map()\n  }\n\n  get(keys: K[]): V | undefined {\n    let current: any = this.root\n    for (let i = 0; i < keys.length; i++) {\n      current = current.get(keys[i])\n      if (!current) return undefined\n    }\n    return current\n  }\n\n  set(keys: K[], value: V): void {\n    let current: Map<K, any> = this.root\n    let i\n    for (i = 0; i < keys.length - 1; i++) {\n      let nextCurrent = current.get(keys[i])\n      if (!nextCurrent) {\n        nextCurrent = new Map<K, any>()\n        current.set(keys[i], nextCurrent)\n      }\n      current = nextCurrent\n    }\n    current.set(keys[i], value)\n  }\n\n  delete(keys: K[]): void {\n    const maps: Map<K, any>[] = [this.root]\n    let current: Map<K, any> = this.root\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      maps.push((current = current.get(keys[i])))\n    }\n\n    let mapIdx = maps.length - 1\n    maps[mapIdx].delete(keys[mapIdx])\n\n    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {\n      maps[mapIdx].delete(keys[mapIdx])\n    }\n  }\n}\n", "import { Observable, Subscription, Subject, noop, Subscriber } from \"rxjs\"\nimport { BehaviorObservable } from \"./BehaviorObservable\"\nimport { EMPTY_VALUE } from \"./empty-value\"\nimport { SUSPENSE } from \"../SUSPENSE\"\n\nconst shareLatest = <T>(\n  source$: Observable<T>,\n  defaultValue: T,\n  shouldComplete = true,\n  teardown = noop,\n): BehaviorObservable<T> => {\n  let subject: Subject<T> | null\n  let subscription: Subscriber<T> | null\n  let refCount = 0\n  let currentValue: T = EMPTY_VALUE\n  let promise: Promise<T> | null\n\n  const emitIfEmpty =\n    defaultValue === EMPTY_VALUE\n      ? noop\n      : () => {\n          currentValue === EMPTY_VALUE &&\n            subject &&\n            subject!.next((currentValue = defaultValue))\n        }\n\n  const result = new Observable<T>((subscriber) => {\n    if (!shouldComplete) subscriber.complete = noop\n\n    refCount++\n    let innerSub: Subscription\n\n    subscriber.add(() => {\n      refCount--\n      innerSub.unsubscribe()\n      if (refCount === 0) {\n        currentValue = EMPTY_VALUE\n        if (subscription) {\n          subscription.unsubscribe()\n        }\n        teardown()\n        subject = null\n        subscription = null\n        promise = null\n      }\n    })\n\n    if (!subject) {\n      subject = new Subject<T>()\n      innerSub = subject.subscribe(subscriber)\n      subscription = null\n      subscription = new Subscriber<T>({\n        next: (value: T) => {\n          subject!.next((currentValue = value))\n        },\n        error: (err: any) => {\n          const _subject = subject\n          subscription = null\n          subject = null\n          _subject!.error(err)\n        },\n        complete: () => {\n          subscription = null\n          emitIfEmpty()\n          subject!.complete()\n        },\n      })\n      source$.subscribe(subscription)\n      emitIfEmpty()\n    } else {\n      innerSub = subject.subscribe(subscriber)\n      if (currentValue !== EMPTY_VALUE) {\n        subscriber.next(currentValue)\n      }\n    }\n  }) as BehaviorObservable<T>\n\n  let error: any = EMPTY_VALUE\n  let timeoutToken: any\n  result.gV = (outterSubscription?: Subscription): T => {\n    if ((currentValue as any) !== SUSPENSE && currentValue !== EMPTY_VALUE) {\n      return currentValue\n    }\n    if (defaultValue !== EMPTY_VALUE) return defaultValue\n\n    if (error !== EMPTY_VALUE) {\n      clearTimeout(timeoutToken)\n      timeoutToken = setTimeout(() => {\n        error = EMPTY_VALUE\n      }, 50)\n      throw error\n    }\n\n    if (!subscription) {\n      if (!outterSubscription) throw new Error(\"Missing Subscribe\")\n\n      let err = EMPTY_VALUE\n      const sub = result.subscribe({\n        error(e) {\n          err = e\n        },\n      })\n      if (err !== EMPTY_VALUE) throw err\n\n      outterSubscription.add(sub)\n      return result.gV()\n    }\n    if (promise) throw promise\n\n    throw (promise = new Promise<T>((res, rej) => {\n      const setError = (e: any) => {\n        error = e\n        timeoutToken = setTimeout(() => {\n          error = EMPTY_VALUE\n        }, 50)\n        rej(e)\n        promise = null\n      }\n      const pSubs = subject!.subscribe(\n        (v) => {\n          if (v !== (SUSPENSE as any)) {\n            pSubs.unsubscribe()\n            res(v)\n            promise = null\n          }\n        },\n        setError,\n        () => {\n          setError(new Error(\"Empty observable\"))\n        },\n      )\n      subscription!.add(pSubs)\n    }))\n  }\n\n  return result\n}\nexport default shareLatest\n", "export const EMPTY_VALUE: any = {}\n", "/**\n * This is a special symbol that can be emitted from our observables to let the\n * react hook know that there is a value on its way, and that we want to\n * leverage React Suspense API while we are waiting for that value.\n */\nexport const SUSPENSE = Symbol(\"SUSPENSE\")\n", "import { useEffect, useState, useRef } from \"react\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport { BehaviorObservable } from \"../internal/BehaviorObservable\"\nimport { Subscription } from \"rxjs\"\n\nexport const useObservable = <O>(\n  source$: BehaviorObservable<O>,\n  subscription?: Subscription,\n): Exclude<O, typeof SUSPENSE> => {\n  const [state, setState] = useState<[O, BehaviorObservable<O>]>(() => [\n    source$.gV(subscription),\n    source$,\n  ])\n  const prevStateRef = useRef<O | (() => O)>(state[0])\n\n  if (source$ !== state[1]) {\n    setState([source$.gV(subscription), source$])\n  }\n\n  useEffect(() => {\n    const suspend = () => {\n      setState(() => [source$.gV(), source$])\n    }\n\n    const subscription = source$.subscribe(\n      (value: O | typeof SUSPENSE) => {\n        if (value === SUSPENSE) {\n          suspend()\n        } else {\n          if (!Object.is(prevStateRef.current, value)) {\n            setState([(prevStateRef.current = value), source$])\n          }\n        }\n      },\n      (error: any) => {\n        setState(() => {\n          throw error\n        })\n      },\n    )\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [source$])\n\n  return state[0] as Exclude<O, typeof SUSPENSE>\n}\n", "import React, {\n  useState,\n  Suspense,\n  useEffect,\n  ReactNode,\n  useRef,\n  createContext,\n  useContext,\n} from \"react\"\nimport { Observable, Subscription } from \"rxjs\"\n\nconst SubscriptionContext = createContext<Subscription>(null as any)\nconst { Provider } = SubscriptionContext\nexport const useSubscription = () => useContext(SubscriptionContext)\n\nconst p = Promise.resolve()\nconst Throw = () => {\n  throw p\n}\n\n/**\n * A React Component that:\n * - collects the subscriptions of its children and it unsubscribes them when\n * the component unmounts.\n * - if a source$ property is used, then it ensures that the subscription to the\n * observable will exist before the children gets rendered, and it unsubscribes\n * from it when the component unmounts.\n *\n * If the fallback property is used, then the component will create a Suspense\n * boundary with the provided JSX Element, otherwise it will render null until\n * the subscription exists.\n *\n * @param [source$] (=undefined) - Source observable that the Component will\n * subscrib to before it renders its children.\n * @param [fallback] (=null) - JSX Element to be used by the Suspense boundary.\n *\n * @remarks This Component doesn't trigger any updates from the source$.\n */\nexport const Subscribe: React.FC<{\n  source$?: Observable<any>\n  fallback?: NonNullable<ReactNode> | null\n}> = ({ source$, children, fallback }) => {\n  const subscriptionRef = useRef<Subscription>()\n\n  if (!subscriptionRef.current) {\n    subscriptionRef.current = new Subscription()\n  }\n\n  const [subscribedSource, setSubscribedSource] =\n    useState<Observable<any> | null | undefined>(null)\n\n  if (subscribedSource !== null && subscribedSource !== source$) {\n    if (source$ === undefined) {\n      setSubscribedSource(source$)\n    } else {\n      let result: any\n      try {\n        ;(source$ as any).gV()\n        result = source$\n      } catch (e) {\n        result = e.then ? source$ : null\n      }\n      if (result) {\n        setSubscribedSource(result)\n      }\n    }\n  }\n\n  useEffect(() => {\n    const subscription =\n      source$ &&\n      source$.subscribe({\n        error: (e) =>\n          setSubscribedSource(() => {\n            throw e\n          }),\n      })\n    setSubscribedSource(source$)\n    return () => {\n      subscription && subscription.unsubscribe()\n    }\n  }, [source$])\n\n  useEffect(() => {\n    return () => {\n      subscriptionRef.current!.unsubscribe()\n    }\n  }, [])\n\n  const actualChildren =\n    subscribedSource === source$ ? (\n      <Provider value={subscriptionRef.current!}>{children}</Provider>\n    ) : fallback === undefined ? null : (\n      <Throw />\n    )\n\n  return fallback === undefined ? (\n    actualChildren\n  ) : (\n    <Suspense fallback={fallback}>{actualChildren}</Suspense>\n  )\n}\n", "import { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { noop, Observable } from \"rxjs\"\nimport { useSubscription } from \"../Subscribe\"\nimport shareLatest from \"../internal/share-latest\"\nimport { useObservable } from \"../internal/useObservable\"\n\n/**\n * Accepts: An Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @param observable Source observable to be used by the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectObservable<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n) {\n  const sharedObservable$ = shareLatest<T>(observable, defaultValue, false)\n  const useSub = defaultValue === EMPTY_VALUE ? useSubscription : noop\n  const useStaticObservable = () =>\n    useObservable(sharedObservable$, useSub() as any)\n  return [useStaticObservable, sharedObservable$] as const\n}\n", "import { Observable } from \"rxjs\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport connectFactoryObservable from \"./connectFactoryObservable\"\nimport connectObservable from \"./connectObservable\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @param {T} [defaultValue] - Default value that will be used if the observable\n * has not emitted any values.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<T>(\n  observable: Observable<T>,\n  defaultValue?: T,\n): [() => Exclude<T, typeof SUSPENSE>, Observable<T>]\n\n/**\n * Binds a factory observable to React\n *\n * @param getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @param [defaultValue] - Function or value that will be used of the observable\n * has not emitted.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue?: O | ((...args: A) => O),\n): [(...args: A) => Exclude<O, typeof SUSPENSE>, (...args: A) => Observable<O>]\n\nexport function bind(observable: any, defaultValue: any) {\n  return (\n    typeof observable === \"function\"\n      ? (connectFactoryObservable as any)\n      : connectObservable\n  )(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE)\n}\n", "import { Observable, MonoTypeOperatorFunction } from \"rxjs\"\nimport internalShareLatest from \"./internal/share-latest\"\nimport { EMPTY_VALUE } from \"./internal/empty-value\"\n\n/**\n * A RxJS pipeable operator which shares and replays the latest emitted value.\n * It's the equivalent of:\n *\n * ```ts\n *  source$.pipe(\n *    multicast(() => new ReplaySubject<T>(1)),\n *    refCount(),\n *  )\n * ```\n *\n * @remarks The enhanced observables returned from `connectObservable` and\n * `connectFactoryObservable` have been enhanced with this operator.\n */\nexport const shareLatest =\n  <T>(): MonoTypeOperatorFunction<T> =>\n  (source$: Observable<T>) =>\n    internalShareLatest(source$, EMPTY_VALUE)\n"],
  "mappings": "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",
  "names": []
}
