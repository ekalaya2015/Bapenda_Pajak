var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.tsx
__export(exports, {
  SUSPENSE: () => SUSPENSE,
  Subscribe: () => Subscribe,
  bind: () => bind,
  shareLatest: () => shareLatest2
});

// src/bind/connectFactoryObservable.ts
var import_rxjs3 = __toModule(require("rxjs"));

// src/internal/share-latest.ts
var import_rxjs = __toModule(require("rxjs"));

// src/internal/empty-value.ts
var EMPTY_VALUE = {};

// src/SUSPENSE.ts
var SUSPENSE = Symbol("SUSPENSE");

// src/internal/share-latest.ts
var shareLatest = (source$, defaultValue, shouldComplete = true, teardown = import_rxjs.noop) => {
  let subject;
  let subscription;
  let refCount = 0;
  let currentValue = EMPTY_VALUE;
  let promise;
  const emitIfEmpty = defaultValue === EMPTY_VALUE ? import_rxjs.noop : () => {
    currentValue === EMPTY_VALUE && subject && subject.next(currentValue = defaultValue);
  };
  const result = new import_rxjs.Observable((subscriber) => {
    if (!shouldComplete)
      subscriber.complete = import_rxjs.noop;
    refCount++;
    let innerSub;
    subscriber.add(() => {
      refCount--;
      innerSub.unsubscribe();
      if (refCount === 0) {
        currentValue = EMPTY_VALUE;
        if (subscription) {
          subscription.unsubscribe();
        }
        teardown();
        subject = null;
        subscription = null;
        promise = null;
      }
    });
    if (!subject) {
      subject = new import_rxjs.Subject();
      innerSub = subject.subscribe(subscriber);
      subscription = null;
      subscription = new import_rxjs.Subscriber({
        next: (value) => {
          subject.next(currentValue = value);
        },
        error: (err) => {
          const _subject = subject;
          subscription = null;
          subject = null;
          _subject.error(err);
        },
        complete: () => {
          subscription = null;
          emitIfEmpty();
          subject.complete();
        }
      });
      source$.subscribe(subscription);
      emitIfEmpty();
    } else {
      innerSub = subject.subscribe(subscriber);
      if (currentValue !== EMPTY_VALUE) {
        subscriber.next(currentValue);
      }
    }
  });
  let error = EMPTY_VALUE;
  let timeoutToken;
  result.gV = (outterSubscription) => {
    if (currentValue !== SUSPENSE && currentValue !== EMPTY_VALUE) {
      return currentValue;
    }
    if (defaultValue !== EMPTY_VALUE)
      return defaultValue;
    if (error !== EMPTY_VALUE) {
      clearTimeout(timeoutToken);
      timeoutToken = setTimeout(() => {
        error = EMPTY_VALUE;
      }, 50);
      throw error;
    }
    if (!subscription) {
      if (!outterSubscription)
        throw new Error("Missing Subscribe");
      let err = EMPTY_VALUE;
      const sub = result.subscribe({
        error(e) {
          err = e;
        }
      });
      if (err !== EMPTY_VALUE)
        throw err;
      outterSubscription.add(sub);
      return result.gV();
    }
    if (promise)
      throw promise;
    throw promise = new Promise((res, rej) => {
      const setError = (e) => {
        error = e;
        timeoutToken = setTimeout(() => {
          error = EMPTY_VALUE;
        }, 50);
        rej(e);
        promise = null;
      };
      const pSubs = subject.subscribe((v) => {
        if (v !== SUSPENSE) {
          pSubs.unsubscribe();
          res(v);
          promise = null;
        }
      }, setError, () => {
        setError(new Error("Empty observable"));
      });
      subscription.add(pSubs);
    });
  };
  return result;
};
var share_latest_default = shareLatest;

// src/internal/useObservable.ts
var import_react = __toModule(require("react"));
var useObservable = (source$, subscription) => {
  const [state, setState] = (0, import_react.useState)(() => [
    source$.gV(subscription),
    source$
  ]);
  const prevStateRef = (0, import_react.useRef)(state[0]);
  if (source$ !== state[1]) {
    setState([source$.gV(subscription), source$]);
  }
  (0, import_react.useEffect)(() => {
    const suspend = () => {
      setState(() => [source$.gV(), source$]);
    };
    const subscription2 = source$.subscribe((value) => {
      if (value === SUSPENSE) {
        suspend();
      } else {
        if (!Object.is(prevStateRef.current, value)) {
          setState([prevStateRef.current = value, source$]);
        }
      }
    }, (error) => {
      setState(() => {
        throw error;
      });
    });
    return () => {
      subscription2.unsubscribe();
    };
  }, [source$]);
  return state[0];
};

// src/Subscribe.tsx
var import_react2 = __toModule(require("react"));
var import_rxjs2 = __toModule(require("rxjs"));
var SubscriptionContext = (0, import_react2.createContext)(null);
var { Provider } = SubscriptionContext;
var useSubscription = () => (0, import_react2.useContext)(SubscriptionContext);
var p = Promise.resolve();
var Throw = () => {
  throw p;
};
var Subscribe = ({ source$, children, fallback }) => {
  const subscriptionRef = (0, import_react2.useRef)();
  if (!subscriptionRef.current) {
    subscriptionRef.current = new import_rxjs2.Subscription();
  }
  const [subscribedSource, setSubscribedSource] = (0, import_react2.useState)(null);
  if (subscribedSource !== null && subscribedSource !== source$) {
    if (source$ === void 0) {
      setSubscribedSource(source$);
    } else {
      let result;
      try {
        ;
        source$.gV();
        result = source$;
      } catch (e) {
        result = e.then ? source$ : null;
      }
      if (result) {
        setSubscribedSource(result);
      }
    }
  }
  (0, import_react2.useEffect)(() => {
    const subscription = source$ && source$.subscribe({
      error: (e) => setSubscribedSource(() => {
        throw e;
      })
    });
    setSubscribedSource(source$);
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [source$]);
  (0, import_react2.useEffect)(() => {
    return () => {
      subscriptionRef.current.unsubscribe();
    };
  }, []);
  const actualChildren = subscribedSource === source$ ? /* @__PURE__ */ import_react2.default.createElement(Provider, {
    value: subscriptionRef.current
  }, children) : fallback === void 0 ? null : /* @__PURE__ */ import_react2.default.createElement(Throw, null);
  return fallback === void 0 ? actualChildren : /* @__PURE__ */ import_react2.default.createElement(import_react2.Suspense, {
    fallback
  }, actualChildren);
};

// src/bind/connectFactoryObservable.ts
function connectFactoryObservable(getObservable, defaultValue) {
  const cache = new NestedMap();
  const getDefaultValue = typeof defaultValue === "function" ? defaultValue : () => defaultValue;
  const getSharedObservables$ = (input) => {
    for (let i = input.length - 1; input[i] === void 0 && i > -1; i--) {
      input.splice(-1);
    }
    const keys = [input.length, ...input];
    const cachedVal = cache.get(keys);
    if (cachedVal !== void 0) {
      return cachedVal;
    }
    const sharedObservable$ = share_latest_default(new import_rxjs3.Observable((observer) => getObservable(...input).subscribe(observer)), getDefaultValue(...input), false, () => {
      cache.delete(keys);
    });
    const publicShared$ = new import_rxjs3.Observable((subscriber) => {
      const inCache = cache.get(keys);
      let source$ = sharedObservable$;
      if (!inCache) {
        cache.set(keys, result);
      } else if (inCache !== publicShared$) {
        source$ = inCache;
        publicShared$.gV = source$.gV;
      }
      return source$.subscribe(subscriber);
    });
    publicShared$.gV = sharedObservable$.gV;
    const result = publicShared$;
    cache.set(keys, result);
    return result;
  };
  const useSub = defaultValue === EMPTY_VALUE ? useSubscription : import_rxjs3.noop;
  return [
    (...input) => useObservable(getSharedObservables$(input), useSub()),
    (...input) => getSharedObservables$(input)
  ];
}
var NestedMap = class {
  constructor() {
    __publicField(this, "root");
    this.root = new Map();
  }
  get(keys) {
    let current = this.root;
    for (let i = 0; i < keys.length; i++) {
      current = current.get(keys[i]);
      if (!current)
        return void 0;
    }
    return current;
  }
  set(keys, value) {
    let current = this.root;
    let i;
    for (i = 0; i < keys.length - 1; i++) {
      let nextCurrent = current.get(keys[i]);
      if (!nextCurrent) {
        nextCurrent = new Map();
        current.set(keys[i], nextCurrent);
      }
      current = nextCurrent;
    }
    current.set(keys[i], value);
  }
  delete(keys) {
    const maps = [this.root];
    let current = this.root;
    for (let i = 0; i < keys.length - 1; i++) {
      maps.push(current = current.get(keys[i]));
    }
    let mapIdx = maps.length - 1;
    maps[mapIdx].delete(keys[mapIdx]);
    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {
      maps[mapIdx].delete(keys[mapIdx]);
    }
  }
};

// src/bind/connectObservable.ts
var import_rxjs4 = __toModule(require("rxjs"));
function connectObservable(observable, defaultValue) {
  const sharedObservable$ = share_latest_default(observable, defaultValue, false);
  const useSub = defaultValue === EMPTY_VALUE ? useSubscription : import_rxjs4.noop;
  const useStaticObservable = () => useObservable(sharedObservable$, useSub());
  return [useStaticObservable, sharedObservable$];
}

// src/bind/index.ts
function bind(observable, defaultValue) {
  return (typeof observable === "function" ? connectFactoryObservable : connectObservable)(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE);
}

// src/shareLatest.ts
var shareLatest2 = () => (source$) => share_latest_default(source$, EMPTY_VALUE);
//# sourceMappingURL=core.cjs.development.js.map
