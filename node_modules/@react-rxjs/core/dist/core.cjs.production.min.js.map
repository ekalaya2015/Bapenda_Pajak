{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/bind/connectFactoryObservable.ts", "../src/internal/share-latest.ts", "../src/internal/empty-value.ts", "../src/SUSPENSE.ts", "../src/internal/useObservable.ts", "../src/Subscribe.tsx", "../src/bind/connectObservable.ts", "../src/bind/index.ts", "../src/shareLatest.ts"],
  "sourcesContent": ["export { bind } from \"./bind\"\nexport { shareLatest } from \"./shareLatest\"\nexport { SUSPENSE } from \"./SUSPENSE\"\nexport { Subscribe } from \"./Subscribe\"\n", "import { noop, Observable } from \"rxjs\"\nimport shareLatest from \"../internal/share-latest\"\nimport { BehaviorObservable } from \"../internal/BehaviorObservable\"\nimport { useObservable } from \"../internal/useObservable\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { useSubscription } from \"../Subscribe\"\n\n/**\n * Accepts: A factory function that returns an Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @param getObservable Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): [\n  (...args: A) => Exclude<O, typeof SUSPENSE>,\n  (...args: A) => Observable<O>,\n] {\n  const cache = new NestedMap<A, BehaviorObservable<O>>()\n  const getDefaultValue = (\n    typeof defaultValue === \"function\" ? defaultValue : () => defaultValue\n  ) as (...args: A) => O\n\n  const getSharedObservables$ = (input: A): BehaviorObservable<O> => {\n    for (let i = input.length - 1; input[i] === undefined && i > -1; i--) {\n      input.splice(-1)\n    }\n    const keys = [input.length, ...input] as any as A\n    const cachedVal = cache.get(keys)\n\n    if (cachedVal !== undefined) {\n      return cachedVal\n    }\n\n    const sharedObservable$ = shareLatest(\n      new Observable<O>((observer) =>\n        getObservable(...input).subscribe(observer),\n      ),\n      getDefaultValue(...input),\n      false,\n      () => {\n        cache.delete(keys)\n      },\n    )\n\n    const publicShared$ = new Observable<O>((subscriber) => {\n      const inCache = cache.get(keys)\n      let source$: BehaviorObservable<O> = sharedObservable$\n\n      if (!inCache) {\n        cache.set(keys, result)\n      } else if (inCache !== publicShared$) {\n        source$ = inCache\n        publicShared$.gV = source$.gV\n      }\n\n      return source$.subscribe(subscriber)\n    }) as BehaviorObservable<O>\n    publicShared$.gV = sharedObservable$.gV\n\n    const result: BehaviorObservable<O> = publicShared$\n\n    cache.set(keys, result)\n    return result\n  }\n\n  const useSub = defaultValue === EMPTY_VALUE ? useSubscription : noop\n  return [\n    (...input: A) =>\n      useObservable(getSharedObservables$(input), useSub() as any),\n    (...input: A) => getSharedObservables$(input),\n  ]\n}\n\nclass NestedMap<K extends [], V extends Object> {\n  private root: Map<K, any>\n  constructor() {\n    this.root = new Map()\n  }\n\n  get(keys: K[]): V | undefined {\n    let current: any = this.root\n    for (let i = 0; i < keys.length; i++) {\n      current = current.get(keys[i])\n      if (!current) return undefined\n    }\n    return current\n  }\n\n  set(keys: K[], value: V): void {\n    let current: Map<K, any> = this.root\n    let i\n    for (i = 0; i < keys.length - 1; i++) {\n      let nextCurrent = current.get(keys[i])\n      if (!nextCurrent) {\n        nextCurrent = new Map<K, any>()\n        current.set(keys[i], nextCurrent)\n      }\n      current = nextCurrent\n    }\n    current.set(keys[i], value)\n  }\n\n  delete(keys: K[]): void {\n    const maps: Map<K, any>[] = [this.root]\n    let current: Map<K, any> = this.root\n\n    for (let i = 0; i < keys.length - 1; i++) {\n      maps.push((current = current.get(keys[i])))\n    }\n\n    let mapIdx = maps.length - 1\n    maps[mapIdx].delete(keys[mapIdx])\n\n    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {\n      maps[mapIdx].delete(keys[mapIdx])\n    }\n  }\n}\n", "import { Observable, Subscription, Subject, noop, Subscriber } from \"rxjs\"\nimport { BehaviorObservable } from \"./BehaviorObservable\"\nimport { EMPTY_VALUE } from \"./empty-value\"\nimport { SUSPENSE } from \"../SUSPENSE\"\n\nconst shareLatest = <T>(\n  source$: Observable<T>,\n  defaultValue: T,\n  shouldComplete = true,\n  teardown = noop,\n): BehaviorObservable<T> => {\n  let subject: Subject<T> | null\n  let subscription: Subscriber<T> | null\n  let refCount = 0\n  let currentValue: T = EMPTY_VALUE\n  let promise: Promise<T> | null\n\n  const emitIfEmpty =\n    defaultValue === EMPTY_VALUE\n      ? noop\n      : () => {\n          currentValue === EMPTY_VALUE &&\n            subject &&\n            subject!.next((currentValue = defaultValue))\n        }\n\n  const result = new Observable<T>((subscriber) => {\n    if (!shouldComplete) subscriber.complete = noop\n\n    refCount++\n    let innerSub: Subscription\n\n    subscriber.add(() => {\n      refCount--\n      innerSub.unsubscribe()\n      if (refCount === 0) {\n        currentValue = EMPTY_VALUE\n        if (subscription) {\n          subscription.unsubscribe()\n        }\n        teardown()\n        subject = null\n        subscription = null\n        promise = null\n      }\n    })\n\n    if (!subject) {\n      subject = new Subject<T>()\n      innerSub = subject.subscribe(subscriber)\n      subscription = null\n      subscription = new Subscriber<T>({\n        next: (value: T) => {\n          subject!.next((currentValue = value))\n        },\n        error: (err: any) => {\n          const _subject = subject\n          subscription = null\n          subject = null\n          _subject!.error(err)\n        },\n        complete: () => {\n          subscription = null\n          emitIfEmpty()\n          subject!.complete()\n        },\n      })\n      source$.subscribe(subscription)\n      emitIfEmpty()\n    } else {\n      innerSub = subject.subscribe(subscriber)\n      if (currentValue !== EMPTY_VALUE) {\n        subscriber.next(currentValue)\n      }\n    }\n  }) as BehaviorObservable<T>\n\n  let error: any = EMPTY_VALUE\n  let timeoutToken: any\n  result.gV = (outterSubscription?: Subscription): T => {\n    if ((currentValue as any) !== SUSPENSE && currentValue !== EMPTY_VALUE) {\n      return currentValue\n    }\n    if (defaultValue !== EMPTY_VALUE) return defaultValue\n\n    if (error !== EMPTY_VALUE) {\n      clearTimeout(timeoutToken)\n      timeoutToken = setTimeout(() => {\n        error = EMPTY_VALUE\n      }, 50)\n      throw error\n    }\n\n    if (!subscription) {\n      if (!outterSubscription) throw new Error(\"Missing Subscribe\")\n\n      let err = EMPTY_VALUE\n      const sub = result.subscribe({\n        error(e) {\n          err = e\n        },\n      })\n      if (err !== EMPTY_VALUE) throw err\n\n      outterSubscription.add(sub)\n      return result.gV()\n    }\n    if (promise) throw promise\n\n    throw (promise = new Promise<T>((res, rej) => {\n      const setError = (e: any) => {\n        error = e\n        timeoutToken = setTimeout(() => {\n          error = EMPTY_VALUE\n        }, 50)\n        rej(e)\n        promise = null\n      }\n      const pSubs = subject!.subscribe(\n        (v) => {\n          if (v !== (SUSPENSE as any)) {\n            pSubs.unsubscribe()\n            res(v)\n            promise = null\n          }\n        },\n        setError,\n        () => {\n          setError(new Error(\"Empty observable\"))\n        },\n      )\n      subscription!.add(pSubs)\n    }))\n  }\n\n  return result\n}\nexport default shareLatest\n", "export const EMPTY_VALUE: any = {}\n", "/**\n * This is a special symbol that can be emitted from our observables to let the\n * react hook know that there is a value on its way, and that we want to\n * leverage React Suspense API while we are waiting for that value.\n */\nexport const SUSPENSE = Symbol(\"SUSPENSE\")\n", "import { useEffect, useState, useRef } from \"react\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport { BehaviorObservable } from \"../internal/BehaviorObservable\"\nimport { Subscription } from \"rxjs\"\n\nexport const useObservable = <O>(\n  source$: BehaviorObservable<O>,\n  subscription?: Subscription,\n): Exclude<O, typeof SUSPENSE> => {\n  const [state, setState] = useState<[O, BehaviorObservable<O>]>(() => [\n    source$.gV(subscription),\n    source$,\n  ])\n  const prevStateRef = useRef<O | (() => O)>(state[0])\n\n  if (source$ !== state[1]) {\n    setState([source$.gV(subscription), source$])\n  }\n\n  useEffect(() => {\n    const suspend = () => {\n      setState(() => [source$.gV(), source$])\n    }\n\n    const subscription = source$.subscribe(\n      (value: O | typeof SUSPENSE) => {\n        if (value === SUSPENSE) {\n          suspend()\n        } else {\n          if (!Object.is(prevStateRef.current, value)) {\n            setState([(prevStateRef.current = value), source$])\n          }\n        }\n      },\n      (error: any) => {\n        setState(() => {\n          throw error\n        })\n      },\n    )\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [source$])\n\n  return state[0] as Exclude<O, typeof SUSPENSE>\n}\n", "import React, {\n  useState,\n  Suspense,\n  useEffect,\n  ReactNode,\n  useRef,\n  createContext,\n  useContext,\n} from \"react\"\nimport { Observable, Subscription } from \"rxjs\"\n\nconst SubscriptionContext = createContext<Subscription>(null as any)\nconst { Provider } = SubscriptionContext\nexport const useSubscription = () => useContext(SubscriptionContext)\n\nconst p = Promise.resolve()\nconst Throw = () => {\n  throw p\n}\n\n/**\n * A React Component that:\n * - collects the subscriptions of its children and it unsubscribes them when\n * the component unmounts.\n * - if a source$ property is used, then it ensures that the subscription to the\n * observable will exist before the children gets rendered, and it unsubscribes\n * from it when the component unmounts.\n *\n * If the fallback property is used, then the component will create a Suspense\n * boundary with the provided JSX Element, otherwise it will render null until\n * the subscription exists.\n *\n * @param [source$] (=undefined) - Source observable that the Component will\n * subscrib to before it renders its children.\n * @param [fallback] (=null) - JSX Element to be used by the Suspense boundary.\n *\n * @remarks This Component doesn't trigger any updates from the source$.\n */\nexport const Subscribe: React.FC<{\n  source$?: Observable<any>\n  fallback?: NonNullable<ReactNode> | null\n}> = ({ source$, children, fallback }) => {\n  const subscriptionRef = useRef<Subscription>()\n\n  if (!subscriptionRef.current) {\n    subscriptionRef.current = new Subscription()\n  }\n\n  const [subscribedSource, setSubscribedSource] = useState<\n    Observable<any> | null | undefined\n  >(null)\n\n  if (subscribedSource !== null && subscribedSource !== source$) {\n    if (source$ === undefined) {\n      setSubscribedSource(source$)\n    } else {\n      let result: any\n      try {\n        ;(source$ as any).gV()\n        result = source$\n      } catch (e: any) {\n        result = e.then ? source$ : null\n      }\n      if (result) {\n        setSubscribedSource(result)\n      }\n    }\n  }\n\n  useEffect(() => {\n    const subscription =\n      source$ &&\n      source$.subscribe({\n        error: (e) =>\n          setSubscribedSource(() => {\n            throw e\n          }),\n      })\n    setSubscribedSource(source$)\n    return () => {\n      subscription && subscription.unsubscribe()\n    }\n  }, [source$])\n\n  useEffect(() => {\n    return () => {\n      subscriptionRef.current!.unsubscribe()\n    }\n  }, [])\n\n  const actualChildren =\n    subscribedSource === source$ ? (\n      <Provider value={subscriptionRef.current!}>{children}</Provider>\n    ) : fallback === undefined ? null : (\n      <Throw />\n    )\n\n  return fallback === undefined ? (\n    actualChildren\n  ) : (\n    <Suspense fallback={fallback}>{actualChildren}</Suspense>\n  )\n}\n", "import { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { noop, Observable } from \"rxjs\"\nimport { useSubscription } from \"../Subscribe\"\nimport shareLatest from \"../internal/share-latest\"\nimport { useObservable } from \"../internal/useObservable\"\n\n/**\n * Accepts: An Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @param observable Source observable to be used by the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectObservable<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n) {\n  const sharedObservable$ = shareLatest<T>(observable, defaultValue, false)\n  const useSub = defaultValue === EMPTY_VALUE ? useSubscription : noop\n  const useStaticObservable = () =>\n    useObservable(sharedObservable$, useSub() as any)\n  return [useStaticObservable, sharedObservable$] as const\n}\n", "import { Observable } from \"rxjs\"\nimport { SUSPENSE } from \"../SUSPENSE\"\nimport connectFactoryObservable from \"./connectFactoryObservable\"\nimport connectObservable from \"./connectObservable\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @param {T} [defaultValue] - Default value that will be used if the observable\n * has not emitted any values.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<T>(\n  observable: Observable<T>,\n  defaultValue?: T,\n): [() => Exclude<T, typeof SUSPENSE>, Observable<T>]\n\n/**\n * Binds a factory observable to React\n *\n * @param getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @param [defaultValue] - Function or value that will be used of the observable\n * has not emitted.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue?: O | ((...args: A) => O),\n): [(...args: A) => Exclude<O, typeof SUSPENSE>, (...args: A) => Observable<O>]\n\nexport function bind(observable: any, defaultValue: any) {\n  return (\n    typeof observable === \"function\"\n      ? (connectFactoryObservable as any)\n      : connectObservable\n  )(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE)\n}\n", "import { Observable, MonoTypeOperatorFunction } from \"rxjs\"\nimport internalShareLatest from \"./internal/share-latest\"\nimport { EMPTY_VALUE } from \"./internal/empty-value\"\n\n/**\n * A RxJS pipeable operator which shares and replays the latest emitted value.\n * It's the equivalent of:\n *\n * ```ts\n *  source$.pipe(\n *    multicast(() => new ReplaySubject<T>(1)),\n *    refCount(),\n *  )\n * ```\n *\n * @remarks The enhanced observables returned from `connectObservable` and\n * `connectFactoryObservable` have been enhanced with this operator.\n */\nexport const shareLatest =\n  <T>(): MonoTypeOperatorFunction<T> =>\n  (source$: Observable<T>) =>\n    internalShareLatest(source$, EMPTY_VALUE)\n"],
  "mappings": "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",
  "names": []
}
