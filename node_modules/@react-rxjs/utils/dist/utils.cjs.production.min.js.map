{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/combineKeys.ts", "../src/createSignal.ts", "../src/createKeyedSignal.ts", "../src/mergeWithKey.ts", "../src/partitionByKey.ts", "../src/suspend.ts", "../src/internal-utils.ts", "../src/suspended.ts", "../src/switchMapSuspended.ts", "../src/selfDependant.ts", "../src/contextBinder.ts", "../src/createListener.ts"],
  "sourcesContent": ["export { combineKeys, MapWithChanges } from \"./combineKeys\"\nexport { createSignal } from \"./createSignal\"\nexport { createKeyedSignal } from \"./createKeyedSignal\"\nexport { mergeWithKey } from \"./mergeWithKey\"\nexport { partitionByKey } from \"./partitionByKey\"\nexport { suspend } from \"./suspend\"\nexport { suspended } from \"./suspended\"\nexport { switchMapSuspended } from \"./switchMapSuspended\"\nexport { selfDependant } from \"./selfDependant\"\nexport { contextBinder } from \"./contextBinder\"\n\nexport { createListener } from \"./createListener\"\n", "import { Observable, Subscription } from \"rxjs\"\n\nexport interface MapWithChanges<K, V> extends Map<K, V> {\n  changes: Set<K>\n}\n\n/**\n * Creates a stream that combines the result of the streams from each key of the input stream.\n *\n * @param keys$ Stream of the list of keys to subscribe to.\n * @param getInner$ Function that returns the stream for each key.\n * @returns An stream with a map containing the latest value from the stream of each key.\n */\nexport const combineKeys = <K, T>(\n  keys$: Observable<Array<K> | Set<K>>,\n  getInner$: (key: K) => Observable<T>,\n): Observable<MapWithChanges<K, T>> =>\n  new Observable((observer) => {\n    const innerSubscriptions = new Map<K, Subscription>()\n    let changes = new Set<K>()\n    const currentValue = new Map<K, T>()\n    let updatingSource = false\n    let isPristine = true\n\n    const next = () => {\n      if (!updatingSource) {\n        const result = Object.assign(new Map(currentValue), {\n          changes,\n        })\n        changes = new Set<K>()\n        isPristine = false\n        observer.next(result)\n      }\n    }\n\n    const subscription = keys$.subscribe(\n      (nextKeysArr) => {\n        updatingSource = true\n        const nextKeys = new Set(nextKeysArr)\n        innerSubscriptions.forEach((sub, key) => {\n          if (!nextKeys.has(key)) {\n            sub.unsubscribe()\n            innerSubscriptions.delete(key)\n            if (currentValue.has(key)) {\n              changes.add(key)\n              currentValue.delete(key)\n            }\n          } else {\n            nextKeys.delete(key)\n          }\n        })\n        nextKeys.forEach((key) => {\n          innerSubscriptions.set(\n            key,\n            getInner$(key).subscribe(\n              (x) => {\n                if (!currentValue.has(key) || currentValue.get(key) !== x) {\n                  changes.add(key)\n                  currentValue.set(key, x)\n                  next()\n                }\n              },\n              (e) => {\n                observer.error(e)\n              },\n            ),\n          )\n        })\n        updatingSource = false\n        // If there are no changes but the nextKeys are an empty iterator\n        // and we have never emitted before, that means that the first\n        // value that keys$ has emitted is an empty iterator, therefore\n        // we should emit an empy Map\n        if (changes.size || (isPristine && !nextKeys.size)) next()\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n\n    return () => {\n      subscription.unsubscribe()\n      innerSubscriptions.forEach((sub) => {\n        sub.unsubscribe()\n      })\n    }\n  })\n", "import { identity, Observable, Subject } from \"rxjs\"\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @param mapper a mapper function, for mapping the arguments of the emitter function into\n * the value of the Observable.\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<void>\n * 2. The emitter function.\n */\nexport function createSignal(): [Observable<void>, () => void]\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<T>(): [Observable<T>, (payload: T) => void]\n\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T = identity as any,\n): [Observable<T>, (...args: A) => void] {\n  const subject = new Subject<T>()\n  return [subject.asObservable(), (...args: A) => subject.next(mapper(...args))]\n}\n", "import { GroupedObservable, Observable, Observer } from \"rxjs\"\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<T, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<T>(): [\n  (key: T) => GroupedObservable<T, T>,\n  (key: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(): [\n  (key: K) => GroupedObservable<K, T>,\n  (key: K, value: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(\n  keySelector: (signal: T) => K,\n): [(key: K) => GroupedObservable<K, T>, (signal: T) => void]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @param mapper a function that maps the arguments of the emitter function to the value of the GroupedObservable\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function (...args: any[]) => T.\n */\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector: (signal: T) => K,\n  mapper: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void]\n\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector?: (signal: T) => K,\n  mapper?: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void] {\n  const observersMap = new Map<K, Set<Observer<T>>>()\n\n  return [\n    (key: K) => {\n      const res = new Observable<T>((observer) => {\n        if (!observersMap.has(key)) {\n          observersMap.set(key, new Set())\n        }\n        const set = observersMap.get(key)!\n        set.add(observer)\n        return () => {\n          set.delete(observer)\n          if (set.size === 0) {\n            observersMap.delete(key)\n          }\n        }\n      }) as GroupedObservable<K, T>\n      ;(res as any).key = key\n      return res\n    },\n    (...args: A) => {\n      const payload = mapper\n        ? mapper(...args)\n        : args.length === 2\n        ? args[1]\n        : args[0]\n      const key = keySelector ? keySelector(payload) : args[0]\n      observersMap.get(key)?.forEach((o) => {\n        o.next(payload)\n      })\n    },\n  ]\n}\n", "import { merge, Observable, ObservableInput, from, SchedulerLike } from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\n/**\n * Emits the values from all the streams of the provided object, in a result\n * which provides the key of the stream of that emission.\n *\n * @param input object of streams\n */\nexport const mergeWithKey: <\n  O extends { [P in keyof any]: ObservableInput<any> },\n  OT extends {\n    [K in keyof O]: O[K] extends ObservableInput<infer V>\n      ? { type: K; payload: V }\n      : unknown\n  },\n>(\n  x: O,\n  concurrent?: number,\n  scheduler?: SchedulerLike,\n) => Observable<OT[keyof O]> = (input, ...optionalArgs) =>\n  merge<any[]>(\n    ...(Object.entries(input)\n      .map(\n        ([type, stream]) =>\n          from(stream).pipe(\n            map((payload) => ({ type, payload } as any)),\n          ) as any,\n      )\n      .concat(optionalArgs) as any[]),\n  )\n", "import { shareLatest } from \"@react-rxjs/core\"\nimport {\n  GroupedObservable,\n  noop,\n  Observable,\n  Subject,\n  Subscription,\n  identity,\n} from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @param streamSelector Function to apply to each resulting group\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream with the list of active keys\n */\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<K[]>]\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream with the list of active keys\n */\nexport function partitionByKey<T, K>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n): [(key: K) => GroupedObservable<K, T>, Observable<K[]>]\n\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector?: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<K[]>] {\n  const groupedObservables$ = new Observable<Map<K, GroupedObservable<K, R>>>(\n    (subscriber) => {\n      const groups: Map<K, InnerGroup<T, K, R>> = new Map()\n\n      let emitted = false\n      let sourceCompleted = false\n      const sub = stream.subscribe(\n        (x) => {\n          const key = keySelector(x)\n          if (groups.has(key)) {\n            return groups.get(key)!.source.next(x)\n          }\n\n          const subject = new Subject<T>()\n\n          const res = shareLatest()(\n            (streamSelector || identity)(subject, key),\n          ) as GroupedObservable<K, R>\n          ;(res as any).key = key\n\n          const innerGroup: InnerGroup<T, K, R> = {\n            source: subject,\n            observable: res,\n            subscription: new Subscription(),\n          }\n          groups.set(key, innerGroup)\n\n          innerGroup.subscription = res.subscribe(\n            noop,\n            (e) => subscriber.error(e),\n            () => {\n              groups.delete(key)\n              subscriber.next(mapGroups(groups))\n\n              if (groups.size === 0 && sourceCompleted) {\n                subscriber.complete()\n              }\n            },\n          )\n\n          subject.next(x)\n          subscriber.next(mapGroups(groups))\n          emitted = true\n        },\n        (e) => {\n          sourceCompleted = true\n          if (groups.size) {\n            groups.forEach((g) => g.source.error(e))\n          } else {\n            subscriber.error(e)\n          }\n        },\n        () => {\n          sourceCompleted = true\n          if (groups.size) {\n            groups.forEach((g) => g.source.complete())\n          } else {\n            subscriber.complete()\n          }\n        },\n      )\n\n      if (!emitted) subscriber.next(mapGroups(groups))\n\n      return () => {\n        sub.unsubscribe()\n        groups.forEach((g) => {\n          g.source.unsubscribe()\n          g.subscription.unsubscribe()\n        })\n      }\n    },\n  ).pipe(shareLatest())\n\n  return [\n    (key: K) => getGroupedObservable(groupedObservables$, key),\n    groupedObservables$.pipe(map((x) => Array.from(x.keys()))),\n  ]\n}\n\ninterface InnerGroup<T, K, R> {\n  source: Subject<T>\n  observable: GroupedObservable<K, R>\n  subscription: Subscription\n}\n\nfunction mapGroups<T, K, R>(\n  groups: Map<K, InnerGroup<T, K, R>>,\n): Map<K, GroupedObservable<K, R>> {\n  return new Map(\n    Array.from(groups.entries()).map(([key, group]) => [key, group.observable]),\n  )\n}\n\nconst getGroupedObservable = <K, T>(\n  source$: Observable<Map<K, GroupedObservable<K, T>>>,\n  key: K,\n) => {\n  const result = new Observable<T>((observer) => {\n    let innerSub: Subscription | undefined\n    let outterSub: Subscription = source$.subscribe(\n      (n) => {\n        innerSub = innerSub || n.get(key)?.subscribe(observer)\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n    return () => {\n      innerSub?.unsubscribe()\n      outterSub.unsubscribe()\n    }\n  }) as GroupedObservable<K, T>\n  ;(result as any).key = key\n  return result\n}\n", "import { ObservableInput, from, Observable } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\nimport { defaultStart } from \"./internal-utils\"\n\n/**\n * A RxJS creation operator that prepends a SUSPENSE on the source observable.\n *\n * @param source$ Source observable\n */\nexport const suspend: <T>(\n  source$: ObservableInput<T>,\n) => Observable<T | typeof SUSPENSE> = <T>(source$: ObservableInput<T>) =>\n  defaultStart(SUSPENSE)(from(source$)) as any\n", "import { Observable } from \"rxjs\"\n\nexport const defaultStart =\n  <T, D>(value: D) =>\n  (source$: Observable<T>) =>\n    new Observable<T | D>((observer) => {\n      let emitted = false\n      const subscription = source$.subscribe(\n        (x) => {\n          emitted = true\n          observer.next(x)\n        },\n        (e) => {\n          observer.error(e)\n        },\n        () => {\n          observer.complete()\n        },\n      )\n\n      if (!emitted) {\n        observer.next(value)\n      }\n\n      return subscription\n    })\n", "import { suspend } from \"./suspend\"\nimport { OperatorFunction } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * A RxJS pipeable operator that prepends a SUSPENSE on the source observable.\n */\nexport const suspended = <T>(): OperatorFunction<T, T | typeof SUSPENSE> =>\n  suspend\n", "import { ObservableInput, OperatorFunction, ObservedValueOf, pipe } from \"rxjs\"\nimport { switchMap } from \"rxjs/operators\"\nimport { suspend } from \"./suspend\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * Same behaviour as rxjs' `switchMap`, but prepending every new event with\n * SUSPENSE.\n *\n * @param fn Projection function\n */\nexport const switchMapSuspended = <T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n): OperatorFunction<T, ObservedValueOf<O> | typeof SUSPENSE> =>\n  pipe(switchMap((x, index) => suspend(project(x, index))))\n", "import { Observable, Subject, MonoTypeOperatorFunction } from \"rxjs\"\nimport { tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies\n *\n * @returns [1, 2]\n * 1. The inner subject as an Observable\n * 2. A pipable operator that taps into the inner Subject\n */\nexport const selfDependant = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const mirrored$ = new Subject<T>()\n  return [\n    mirrored$.asObservable(),\n    () => tap(mirrored$) as MonoTypeOperatorFunction<T>,\n  ]\n}\n", "import { Observable } from \"rxjs\"\nimport { bind, SUSPENSE } from \"@react-rxjs/core\"\n\ntype SubstractTuples<A1, A2> = A2 extends [unknown, ...infer Rest2]\n  ? A1 extends [unknown, ...infer Rest1]\n    ? SubstractTuples<Rest1, Rest2>\n    : []\n  : A1\n\nconst execSelf = <T>(fn: () => T) => fn()\n\n/**\n * Returns a version of bind where its hook will have the first parameters bound\n * the results of the provided functions\n *\n * @param {...React.Context} context - The React.Context that should be bound to the hook.\n */\nexport function contextBinder<\n  A extends (() => any)[],\n  OT extends {\n    [K in keyof A]: A[K] extends () => infer V ? V : unknown\n  },\n>(\n  ...args: A\n): <AA extends any[], T, ARGS extends [...OT, ...AA]>(\n  getObservable: (...args: ARGS) => Observable<T>,\n  defaultValue?: T | undefined,\n) => [\n  (...args: SubstractTuples<ARGS, OT>) => Exclude<T, typeof SUSPENSE>,\n  (...args: ARGS) => Observable<T>,\n]\nexport function contextBinder(...args: any[]) {\n  const useArgs = () => args.map(execSelf)\n  return function () {\n    const [hook, getter] = bind.apply(null, arguments as any) as any\n    return [(...args: any[]) => (hook as any)(...useArgs(), ...args), getter]\n  } as any\n}\n", "import { Observable } from \"rxjs\"\nimport { createSignal } from \"./createSignal\"\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener(): [Observable<void>, () => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<T>(): [Observable<T>, (payload: T) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable\n * 2. The emitter function.\n */\nexport function createListener(...args: any[]) {\n  return (createSignal as any)(...args)\n}\n"],
  "mappings": "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",
  "names": []
}
