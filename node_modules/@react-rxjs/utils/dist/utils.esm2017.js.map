{
  "version": 3,
  "sources": ["../src/internal-utils.ts", "../src/collectValues.ts", "../src/collect.ts", "../src/combineKeys.ts", "../src/getGroupedObservable.ts", "../src/createSignal.ts", "../src/createKeyedSignal.ts", "../src/mergeWithKey.ts", "../src/partitionByKey.ts", "../src/split.ts", "../src/suspend.ts", "../src/suspended.ts", "../src/switchMapSuspended.ts", "../src/selfDependant.ts", "../src/contextBinder.ts", "../src/createListener.ts"],
  "sourcesContent": ["import { Observable, GroupedObservable, Subscription } from \"rxjs\"\nimport { shareLatest } from \"@react-rxjs/core\"\n\nexport const defaultStart = <T, D>(value: D) => (source$: Observable<T>) =>\n  new Observable<T | D>((observer) => {\n    let emitted = false\n    const subscription = source$.subscribe(\n      (x) => {\n        emitted = true\n        observer.next(x)\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n\n    if (!emitted) {\n      observer.next(value)\n    }\n\n    return subscription\n  })\n\nexport const collector = <K, V, VV>(\n  enhancer: (source: GroupedObservable<K, V>) => Observable<VV>,\n): ((\n  source: Observable<GroupedObservable<K, V>>,\n) => Observable<Map<K, VV>>) => (source$) =>\n  new Observable<Map<K, VV>>((observer) => {\n    const subscription = new Subscription()\n    const map = new Map<K, VV>()\n    let emitted = false\n\n    subscription.add(\n      source$.subscribe(\n        (x) => {\n          subscription.add(\n            enhancer(x).subscribe(\n              (v) => {\n                map.set(x.key, v)\n                emitted = true\n                observer.next(map)\n              },\n              (e) => {\n                observer.error(e)\n              },\n              () => {\n                map.delete(x.key)\n                observer.next(map)\n              },\n            ),\n          )\n        },\n        (e) => {\n          observer.error(e)\n        },\n        () => {\n          map.clear()\n          observer.next(map)\n          observer.complete()\n        },\n      ),\n    )\n    if (!emitted) observer.next(map)\n    return subscription\n  }).pipe(shareLatest())\n", "import { GroupedObservable, OperatorFunction } from \"rxjs\"\nimport { collector } from \"./internal-utils\"\n\n/** @deprecated collectValues is deprecated and it will be removed in the next version, please use combineKeys\n *\n * A pipeable operator that collects all the GroupedObservables emitted by\n * the source and emits a Map with the latest values of the inner observables.\n */\nexport const collectValues = <K, V>(): OperatorFunction<\n  GroupedObservable<K, V>,\n  Map<K, V>\n> => collector((x) => x)\n", "import { GroupedObservable, noop, Observable } from \"rxjs\"\nimport { collector } from \"./internal-utils\"\n\nconst enhancer = <K, V>(source: GroupedObservable<K, V>) =>\n  new Observable<GroupedObservable<K, V>>((observer) => {\n    const done = () => {\n      observer.complete()\n    }\n    observer.next(source)\n    return source.subscribe(noop, done, done)\n  })\n\n/** @deprecated collect is deprecated and it will be removed in the next version, please use partitionByKey\n *\n * A pipeable operator that collects all the GroupedObservables emitted by\n * the source and emits a Map with the active inner observables\n */\nexport const collect = <K, V>(): ((\n  source$: Observable<GroupedObservable<K, V>>,\n) => Observable<Map<K, GroupedObservable<K, V>>>) => collector(enhancer)\n", "import { Observable, Subscription } from \"rxjs\"\n\n/**\n * Creates a stream that combines the result of the streams from each key of the input stream.\n *\n * @param keys$ Stream of the list of keys to subscribe to.\n * @param getInner$ Function that returns the stream for each key.\n * @returns An stream with a map containing the latest value from the stream of each key.\n */\nexport const combineKeys = <K, T>(\n  keys$: Observable<Array<K> | Set<K>>,\n  getInner$: (key: K) => Observable<T>,\n): Observable<Map<K, T>> =>\n  new Observable((observer) => {\n    const innerSubscriptions = new Map<K, Subscription>()\n    const currentValue = new Map<K, T>()\n    let updatingSource = false\n    const next = () => {\n      if (!updatingSource) observer.next(new Map(currentValue))\n    }\n\n    const subscription = keys$.subscribe(\n      (nextKeysArr) => {\n        updatingSource = true\n        const nextKeys = new Set(nextKeysArr)\n        let changes = false\n        innerSubscriptions.forEach((sub, key) => {\n          if (!nextKeys.has(key)) {\n            sub.unsubscribe()\n            innerSubscriptions.delete(key)\n            if (currentValue.has(key)) {\n              changes = true\n              currentValue.delete(key)\n            }\n          } else {\n            nextKeys.delete(key)\n          }\n        })\n        nextKeys.forEach((key) => {\n          innerSubscriptions.set(\n            key,\n            getInner$(key).subscribe(\n              (x) => {\n                if (!currentValue.has(key) || currentValue.get(key) !== x) {\n                  changes = true\n                  currentValue.set(key, x)\n                  next()\n                }\n              },\n              (e) => {\n                observer.error(e)\n              },\n            ),\n          )\n        })\n        updatingSource = false\n        if (changes) next()\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n\n    return () => {\n      subscription.unsubscribe()\n      innerSubscriptions.forEach((sub) => {\n        sub.unsubscribe()\n      })\n    }\n  })\n", "import { GroupedObservable, Observable, Subscription } from \"rxjs\"\n\nexport const getGroupedObservable = <K, T>(\n  source$: Observable<Map<K, GroupedObservable<K, T>>>,\n  key: K,\n) => {\n  const result = new Observable<T>((observer) => {\n    let innerSub: Subscription | undefined\n    let outterSub: Subscription = source$.subscribe(\n      (n) => {\n        innerSub = innerSub || n.get(key)?.subscribe(observer)\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n    return () => {\n      innerSub?.unsubscribe()\n      outterSub.unsubscribe()\n    }\n  }) as GroupedObservable<K, T>\n  ;(result as any).key = key\n  return result\n}\n", "import { identity, Observable, Subject } from \"rxjs\"\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @param mapper a mapper function, for mapping the arguments of the emitter function into\n * the value of the Observable.\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<void>\n * 2. The emitter function.\n */\nexport function createSignal(): [Observable<void>, () => void]\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<T>(): [Observable<T>, (payload: T) => void]\n\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T = identity as any,\n): [Observable<T>, (...args: A) => void] {\n  const subject = new Subject<T>()\n  return [subject.asObservable(), (...args: A) => subject.next(mapper(...args))]\n}\n", "import { GroupedObservable, Observable, Observer } from \"rxjs\"\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<T, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<T>(): [\n  (key: T) => GroupedObservable<T, T>,\n  (key: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(): [\n  (key: K) => GroupedObservable<K, T>,\n  (key: K, value: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(\n  keySelector: (signal: T) => K,\n): [(key: K) => GroupedObservable<K, T>, (signal: T) => void]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @param mapper a function that maps the arguments of the emitter function to the value of the GroupedObservable\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function (...args: any[]) => T.\n */\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector: (signal: T) => K,\n  mapper: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void]\n\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector?: (signal: T) => K,\n  mapper?: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void] {\n  const observersMap = new Map<K, Set<Observer<T>>>()\n\n  return [\n    (key: K) => {\n      const res = new Observable<T>((observer) => {\n        if (!observersMap.has(key)) {\n          observersMap.set(key, new Set())\n        }\n        const set = observersMap.get(key)!\n        set.add(observer)\n        return () => {\n          set.delete(observer)\n          if (set.size === 0) {\n            observersMap.delete(key)\n          }\n        }\n      }) as GroupedObservable<K, T>\n      ;(res as any).key = key\n      return res\n    },\n    (...args: A) => {\n      const payload = mapper\n        ? mapper(...args)\n        : args.length === 2\n        ? args[1]\n        : args[0]\n      const key = keySelector ? keySelector(payload) : args[0]\n      observersMap.get(key)?.forEach((o) => {\n        o.next(payload)\n      })\n    },\n  ]\n}\n", "import { merge, Observable, ObservableInput, from, SchedulerLike } from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\n/**\n * Emits the values from all the streams of the provided object, in a result\n * which provides the key of the stream of that emission.\n *\n * @param input object of streams\n */\nexport const mergeWithKey: <\n  O extends { [P in keyof any]: ObservableInput<any> },\n  OT extends {\n    [K in keyof O]: O[K] extends ObservableInput<infer V>\n      ? { type: K; payload: V }\n      : unknown\n  },\n>(\n  x: O,\n  concurrent?: number,\n  scheduler?: SchedulerLike,\n) => Observable<OT[keyof O]> = (input, ...optionalArgs) =>\n  merge<any[]>(\n    ...(Object.entries(input)\n      .map(\n        ([type, stream]) =>\n          from(stream).pipe(\n            map((payload) => ({ type, payload } as any)),\n          ) as any,\n      )\n      .concat(optionalArgs) as any[]),\n  )\n", "import { GroupedObservable, Observable } from \"rxjs\"\nimport { map } from \"rxjs/operators\"\nimport { collect, getGroupedObservable, split } from \"./\"\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @param streamSelector Function to apply to each resulting group\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream with the list of active keys\n */\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<K[]>] {\n  const source$ = stream.pipe(split(keySelector, streamSelector), collect())\n  return [\n    (key: K) => getGroupedObservable(source$, key),\n    source$.pipe(map((x) => Array.from(x.keys()))),\n  ]\n}\n", "import {\n  Observable,\n  GroupedObservable,\n  Subject,\n  ReplaySubject,\n  OperatorFunction,\n  noop,\n} from \"rxjs\"\nimport { shareReplay } from \"rxjs/operators\"\n\nconst emptyError = {}\n\n/** @deprecated split is deprecated and it will be removed in the next version, please use partitionByKey\n *\n * Groups the items emitted by the source based on the keySelector function,\n * emitting one Observable for each group.\n *\n * @param keySelector Function to define the group of an item\n */\nexport function split<T, K>(\n  keySelector: (value: T) => K,\n): OperatorFunction<T, GroupedObservable<K, T>>\n\n/** @deprecated split is deprecated and it will be removed in the next version, please use partitionByKey\n *\n * Groups the items emitted by the source based on the keySelector function,\n * emitting one Observable for each group.\n *\n * @param keySelector Function to define the group of an item\n * @param streamSelector Function to apply to each resulting group\n */\nexport function split<T, K, R>(\n  keySelector: (value: T) => K,\n  streamSelector: (grouped: Observable<T>, key: K) => Observable<R>,\n): OperatorFunction<T, GroupedObservable<K, R>>\n\nexport function split<T, K, R>(\n  keySelector: (value: T) => K,\n  streamSelector?: (grouped: Observable<T>, key: K) => Observable<R>,\n): OperatorFunction<T, GroupedObservable<K, R>> {\n  return (stream: Observable<T>) =>\n    new Observable<GroupedObservable<K, R>>((subscriber) => {\n      const groups: Map<K, Subject<T>> = new Map()\n\n      let error = emptyError\n      const sub = stream.subscribe(\n        (x) => {\n          const key = keySelector(x)\n          if (groups.has(key)) {\n            return groups.get(key)!.next(x)\n          }\n\n          const subject = streamSelector\n            ? new Subject<T>()\n            : new ReplaySubject<T>(1)\n          groups.set(key, subject)\n\n          const res = (\n            streamSelector\n              ? streamSelector(subject, key).pipe(shareReplay(1))\n              : subject.asObservable()\n          ) as GroupedObservable<K, R>\n\n          ;(res as any).key = key\n          const onFinish = () => groups.delete(key)\n          res.subscribe(noop, onFinish, onFinish)\n\n          subject.next(x)\n          subscriber.next(res)\n        },\n        (e) => {\n          subscriber.error((error = e))\n        },\n        () => {\n          subscriber.complete()\n        },\n      )\n\n      return () => {\n        sub.unsubscribe()\n        groups.forEach(\n          error === emptyError ? (g) => g.complete() : (g) => g.error(error),\n        )\n      }\n    })\n}\n", "import { ObservableInput, from, Observable } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\nimport { defaultStart } from \"./internal-utils\"\n\n/**\n * A RxJS creation operator that prepends a SUSPENSE on the source observable.\n *\n * @param source$ Source observable\n */\nexport const suspend: <T>(\n  source$: ObservableInput<T>,\n) => Observable<T | typeof SUSPENSE> = <T>(source$: ObservableInput<T>) =>\n  defaultStart(SUSPENSE)(from(source$)) as any\n", "import { suspend } from \"./suspend\"\nimport { OperatorFunction } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * A RxJS pipeable operator that prepends a SUSPENSE on the source observable.\n */\nexport const suspended = <T>(): OperatorFunction<T, T | typeof SUSPENSE> =>\n  suspend\n", "import { ObservableInput, OperatorFunction, ObservedValueOf, pipe } from \"rxjs\"\nimport { switchMap } from \"rxjs/operators\"\nimport { suspend } from \"./suspend\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * Same behaviour as rxjs' `switchMap`, but prepending every new event with\n * SUSPENSE.\n *\n * @param fn Projection function\n */\nexport const switchMapSuspended = <T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n): OperatorFunction<T, ObservedValueOf<O> | typeof SUSPENSE> =>\n  pipe(switchMap((x, index) => suspend(project(x, index))))\n", "import { Observable, Subject, MonoTypeOperatorFunction } from \"rxjs\"\nimport { tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies\n *\n * @returns [1, 2]\n * 1. The inner subject as an Observable\n * 2. A pipable operator that taps into the inner Subject\n */\nexport const selfDependant = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const mirrored$ = new Subject<T>()\n  return [\n    mirrored$.asObservable(),\n    () => tap(mirrored$) as MonoTypeOperatorFunction<T>,\n  ]\n}\n", "import { Observable } from \"rxjs\"\nimport { bind, SUSPENSE } from \"@react-rxjs/core\"\n\ntype SubstractTuples<A1, A2> = A2 extends [unknown, ...infer Rest2]\n  ? A1 extends [unknown, ...infer Rest1]\n    ? SubstractTuples<Rest1, Rest2>\n    : []\n  : A1\n\nconst execSelf = <T>(fn: () => T) => fn()\n\n/**\n * Returns a version of bind where its hook will have the first parameters bound\n * the results of the provided functions\n *\n * @param {...React.Context} context - The React.Context that should be bound to the hook.\n */\nexport function contextBinder<\n  A extends (() => any)[],\n  OT extends {\n    [K in keyof A]: A[K] extends () => infer V ? V : unknown\n  }\n>(\n  ...args: A\n): <AA extends any[], T, ARGS extends [...OT, ...AA]>(\n  getObservable: (...args: ARGS) => Observable<T>,\n  defaultValue?: T | undefined,\n) => [\n  (...args: SubstractTuples<ARGS, OT>) => Exclude<T, typeof SUSPENSE>,\n  (...args: ARGS) => Observable<T>,\n]\nexport function contextBinder(...args: any[]) {\n  const useArgs = () => args.map(execSelf)\n  return function () {\n    const [hook, getter] = bind.apply(null, arguments as any) as any\n    return [(...args: any[]) => (hook as any)(...useArgs(), ...args), getter]\n  } as any\n}\n", "import { Observable } from \"rxjs\"\nimport { createSignal } from \"./createSignal\"\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener(): [Observable<void>, () => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<T>(): [Observable<T>, (payload: T) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable\n * 2. The emitter function.\n */\nexport function createListener(...args: any[]) {\n  return (createSignal as any)(...args)\n}\n"],
  "mappings": "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",
  "names": []
}
