// src/internal-utils.ts
import { Observable, Subscription } from "rxjs";
import { shareLatest } from "@react-rxjs/core";
var defaultStart = (value) => (source$) => new Observable((observer) => {
  let emitted = false;
  const subscription = source$.subscribe((x) => {
    emitted = true;
    observer.next(x);
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  if (!emitted) {
    observer.next(value);
  }
  return subscription;
});
var collector = (enhancer2) => (source$) => new Observable((observer) => {
  const subscription = new Subscription();
  const map3 = new Map();
  let emitted = false;
  subscription.add(source$.subscribe((x) => {
    subscription.add(enhancer2(x).subscribe((v) => {
      map3.set(x.key, v);
      emitted = true;
      observer.next(map3);
    }, (e) => {
      observer.error(e);
    }, () => {
      map3.delete(x.key);
      observer.next(map3);
    }));
  }, (e) => {
    observer.error(e);
  }, () => {
    map3.clear();
    observer.next(map3);
    observer.complete();
  }));
  if (!emitted)
    observer.next(map3);
  return subscription;
}).pipe(shareLatest());

// src/collectValues.ts
var collectValues = () => collector((x) => x);

// src/collect.ts
import { noop, Observable as Observable2 } from "rxjs";
var enhancer = (source) => new Observable2((observer) => {
  const done = () => {
    observer.complete();
  };
  observer.next(source);
  return source.subscribe(noop, done, done);
});
var collect = () => collector(enhancer);

// src/combineKeys.ts
import { Observable as Observable3 } from "rxjs";
var combineKeys = (keys$, getInner$) => new Observable3((observer) => {
  const innerSubscriptions = new Map();
  const currentValue = new Map();
  let updatingSource = false;
  const next = () => {
    if (!updatingSource)
      observer.next(new Map(currentValue));
  };
  const subscription = keys$.subscribe((nextKeysArr) => {
    updatingSource = true;
    const nextKeys = new Set(nextKeysArr);
    let changes = false;
    innerSubscriptions.forEach((sub, key) => {
      if (!nextKeys.has(key)) {
        sub.unsubscribe();
        innerSubscriptions.delete(key);
        if (currentValue.has(key)) {
          changes = true;
          currentValue.delete(key);
        }
      } else {
        nextKeys.delete(key);
      }
    });
    nextKeys.forEach((key) => {
      innerSubscriptions.set(key, getInner$(key).subscribe((x) => {
        if (!currentValue.has(key) || currentValue.get(key) !== x) {
          changes = true;
          currentValue.set(key, x);
          next();
        }
      }, (e) => {
        observer.error(e);
      }));
    });
    updatingSource = false;
    if (changes)
      next();
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  return () => {
    subscription.unsubscribe();
    innerSubscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  };
});

// src/getGroupedObservable.ts
import { Observable as Observable4 } from "rxjs";
var getGroupedObservable = (source$, key) => {
  const result = new Observable4((observer) => {
    let innerSub;
    let outterSub = source$.subscribe((n) => {
      var _a;
      innerSub = innerSub || ((_a = n.get(key)) == null ? void 0 : _a.subscribe(observer));
    }, (e) => {
      observer.error(e);
    }, () => {
      observer.complete();
    });
    return () => {
      innerSub == null ? void 0 : innerSub.unsubscribe();
      outterSub.unsubscribe();
    };
  });
  result.key = key;
  return result;
};

// src/createSignal.ts
import { identity, Subject } from "rxjs";
function createSignal(mapper = identity) {
  const subject = new Subject();
  return [subject.asObservable(), (...args) => subject.next(mapper(...args))];
}

// src/createKeyedSignal.ts
import { Observable as Observable6 } from "rxjs";
function createKeyedSignal(keySelector, mapper) {
  const observersMap = new Map();
  return [
    (key) => {
      const res = new Observable6((observer) => {
        if (!observersMap.has(key)) {
          observersMap.set(key, new Set());
        }
        const set = observersMap.get(key);
        set.add(observer);
        return () => {
          set.delete(observer);
          if (set.size === 0) {
            observersMap.delete(key);
          }
        };
      });
      res.key = key;
      return res;
    },
    (...args) => {
      var _a;
      const payload = mapper ? mapper(...args) : args.length === 2 ? args[1] : args[0];
      const key = keySelector ? keySelector(payload) : args[0];
      (_a = observersMap.get(key)) == null ? void 0 : _a.forEach((o) => {
        o.next(payload);
      });
    }
  ];
}

// src/mergeWithKey.ts
import { merge, from } from "rxjs";
import { map } from "rxjs/operators";
var mergeWithKey = (input, ...optionalArgs) => merge(...Object.entries(input).map(([type, stream]) => from(stream).pipe(map((payload) => ({ type, payload })))).concat(optionalArgs));

// src/partitionByKey.ts
import { map as map2 } from "rxjs/operators";
function partitionByKey(stream, keySelector, streamSelector) {
  const source$ = stream.pipe(split(keySelector, streamSelector), collect());
  return [
    (key) => getGroupedObservable(source$, key),
    source$.pipe(map2((x) => Array.from(x.keys())))
  ];
}

// src/split.ts
import {
  Observable as Observable8,
  Subject as Subject2,
  ReplaySubject,
  noop as noop2
} from "rxjs";
import { shareReplay } from "rxjs/operators";
var emptyError = {};
function split(keySelector, streamSelector) {
  return (stream) => new Observable8((subscriber) => {
    const groups = new Map();
    let error = emptyError;
    const sub = stream.subscribe((x) => {
      const key = keySelector(x);
      if (groups.has(key)) {
        return groups.get(key).next(x);
      }
      const subject = streamSelector ? new Subject2() : new ReplaySubject(1);
      groups.set(key, subject);
      const res = streamSelector ? streamSelector(subject, key).pipe(shareReplay(1)) : subject.asObservable();
      res.key = key;
      const onFinish = () => groups.delete(key);
      res.subscribe(noop2, onFinish, onFinish);
      subject.next(x);
      subscriber.next(res);
    }, (e) => {
      subscriber.error(error = e);
    }, () => {
      subscriber.complete();
    });
    return () => {
      sub.unsubscribe();
      groups.forEach(error === emptyError ? (g) => g.complete() : (g) => g.error(error));
    };
  });
}

// src/suspend.ts
import { from as from2 } from "rxjs";
import { SUSPENSE } from "@react-rxjs/core";
var suspend = (source$) => defaultStart(SUSPENSE)(from2(source$));

// src/suspended.ts
var suspended = () => suspend;

// src/switchMapSuspended.ts
import { pipe } from "rxjs";
import { switchMap } from "rxjs/operators";
var switchMapSuspended = (project) => pipe(switchMap((x, index) => suspend(project(x, index))));

// src/selfDependant.ts
import { Subject as Subject3 } from "rxjs";
import { tap } from "rxjs/operators";
var selfDependant = () => {
  const mirrored$ = new Subject3();
  return [
    mirrored$.asObservable(),
    () => tap(mirrored$)
  ];
};

// src/contextBinder.ts
import { bind } from "@react-rxjs/core";
var execSelf = (fn) => fn();
function contextBinder(...args) {
  const useArgs = () => args.map(execSelf);
  return function() {
    const [hook, getter] = bind.apply(null, arguments);
    return [(...args2) => hook(...useArgs(), ...args2), getter];
  };
}

// src/createListener.ts
function createListener(...args) {
  return createSignal(...args);
}
export {
  collect,
  collectValues,
  combineKeys,
  contextBinder,
  createKeyedSignal,
  createListener,
  createSignal,
  getGroupedObservable,
  mergeWithKey,
  partitionByKey,
  selfDependant,
  split,
  suspend,
  suspended,
  switchMapSuspended
};
//# sourceMappingURL=utils.esm2019.js.map
